Index: app/src/main/java/neurelectrics/fitbitdatalogger/MainActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package neurelectrics.fitbitdatalogger;\r\n\r\nimport android.Manifest;\r\nimport android.app.AlarmManager;\r\nimport android.app.AlertDialog;\r\nimport android.app.PendingIntent;\r\nimport android.bluetooth.BluetoothAdapter;\r\nimport android.content.Context;\r\nimport android.content.DialogInterface;\r\nimport android.content.Intent;\r\nimport android.content.IntentFilter;\r\nimport android.content.SharedPreferences;\r\nimport android.content.pm.PackageManager;\r\nimport android.content.res.ColorStateList;\r\nimport android.graphics.Color;\r\nimport android.media.AudioManager;\r\nimport android.media.MediaPlayer;\r\nimport android.os.AsyncTask;\r\nimport android.os.BatteryManager;\r\nimport android.os.Build;\r\nimport android.os.Environment;\r\nimport android.os.Handler;\r\nimport android.os.PowerManager;\r\nimport android.support.v4.app.ActivityCompat;\r\nimport android.support.v7.app.AppCompatActivity;\r\nimport android.os.Bundle;\r\nimport android.text.InputType;\r\nimport android.util.Log;\r\nimport android.view.KeyEvent;\r\nimport android.view.View;\r\nimport android.view.Window;\r\nimport android.view.WindowManager;\r\nimport android.widget.Button;\r\nimport android.widget.CompoundButton;\r\nimport android.widget.EditText;\r\nimport android.widget.SeekBar;\r\nimport android.widget.TextView;\r\nimport android.widget.ToggleButton;\r\n\r\nimport com.github.javiersantos.appupdater.AppUpdater;\r\nimport com.github.javiersantos.appupdater.enums.UpdateFrom;\r\n\r\nimport org.apache.commons.math3.stat.descriptive.moment.StandardDeviation;\r\nimport org.apache.http.client.methods.HttpPost;\r\nimport org.json.JSONException;\r\nimport org.json.JSONObject;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.FileReader;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.PrintWriter;\r\nimport java.net.Socket;\r\nimport java.net.URL;\r\nimport java.net.URLEncoder;\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.util.ArrayList;\r\nimport java.util.Calendar;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\nimport fi.iki.elonen.NanoHTTPD;\r\n\r\npublic class MainActivity extends AppCompatActivity {\r\n\r\n    //TMR control variables\r\n    private String USER_ID;\r\n    private String DEFAULT_USER_ID = \"DEFAULT\";\r\n    private String USER_ID_FILE_NAME = \"userID.txt\";\r\n    private String DEFAULT_SETTINGS_FILE_NAME = \"modelSettings.txt\";\r\n    float ONSET_CONFIDENCE=0.75f;\r\n    int BUFFER_SIZE = 240;\r\n    float E_STOP=0.3f; //emergency stop cueing\r\n    int BACKOFF_TIME=5*60000;\r\n    int MAX_STIM=2000;\r\n    float CUE_NOISE_OFFSET=0.01f; //how much louder is the cue than the white noise\r\n    float CUE_NOISE_MAX=0.01f; //how much louder can the cues get than white noise\r\n    float MAX_ADAPTION_STEP=0.015f; //If cues seem to trigger a wakeup, drop the max volume we can reach by this much\r\n    long ONSET_DELAY=60*60*1000; //minimumj delay before cues start\r\n    long OFFSET_DELAY=3*60*60*1000;\r\n    boolean DEBUG_MODE=false; //if true, app simulates stage 3 sleep\r\n    long turnedOnTime=0;\r\n    int above_thresh=0;\r\n    double backoff_time=0;\r\n    int stim_seconds=0;\r\n    double lastpacket=0;\r\n    float targetVolume=1.0f;\r\n    float volumeInc=(0.05f/200f);\r\n\r\n\r\n    fitbitServer server;\r\n    savedDataServer fileServer;\r\n    String fitbitStatus=\"\";\r\n    ToggleButton tmrStateButton;\r\n    MediaPlayer whiteNoise;\r\n    double maxNoise = 0.25;\r\n    Float whiteNoiseVolume = (1.0f * (float) maxNoise);\r\n    Float cueNoise;\r\n    TextView volumeText;\r\n    SeekBar volumeBar;\r\n    SharedPreferences volumePreferences;\r\n    boolean isPlaying=false;\r\n    int ZMAX_WRITE_INTERVAL=60*60; //write zmax data every minute\r\n    String zMaxBuffer=\"\";\r\n    int zMaxCount=0;\r\n    int FITBIT_WRITE_INTERVAL=10; //write fitbit data every 10 minutes\r\n    String fitbitBuffer=\"\";\r\n    int fitbitCount=0;\r\n    ArrayList<Float> probBuffer=new ArrayList<Float>();\r\n\r\n\r\n    boolean conFixArm=false; //whether the app can self-restart\r\n    int getWordAt(String[] data,int position) { //get the word (two bytes) from the zMax hex data stream and combine them to make an int\r\n        int data1 = (int) Long.parseLong(data[position], 16); //first two digits are EEG channel 1\r\n        int data2 = (int) Long.parseLong(data[position+1], 16);\r\n        byte d1b = (byte) data1;\r\n        byte d2b = (byte) data2;\r\n        int val = ((d1b & 0xff) << 8) | (d2b & 0xff); //combine two bytes to get an int\r\n        return val;\r\n    }\r\n\r\n    public boolean isPluggedIn() {\r\n        Intent intent = this.registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));\r\n        int plugged = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);\r\n        return plugged == BatteryManager.BATTERY_PLUGGED_AC || plugged == BatteryManager.BATTERY_PLUGGED_USB || plugged == BatteryManager.BATTERY_PLUGGED_WIRELESS;\r\n    }\r\n\r\n\r\n    public String getDeviceName() {\r\n        String manufacturer = Build.MANUFACTURER;\r\n        String model = Build.MODEL;\r\n\r\n            return manufacturer+model;\r\n\r\n    }\r\n\r\n    @Override\r\n    protected void onUserLeaveHint() {\r\n        super.onUserLeaveHint();\r\n        if (conFixArm) {\r\n            Log.e(\"Datacollector\", \"Restarting\");\r\n            Intent intent = new Intent(MainActivity.this, MainActivity.class);\r\n            PendingIntent pendingIntent = PendingIntent.getActivity(MainActivity.this, 0, intent, PendingIntent.FLAG_ONE_SHOT);\r\n            ((AlarmManager) getSystemService(ALARM_SERVICE)).set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + 1000, pendingIntent);\r\n            conFixArm=false;\r\n        }\r\n    }\r\n\r\n/*\r\n    protected void onPause() {\r\n    super.onPause();\r\n        PowerManager pm = (PowerManager) getSystemService(POWER_SERVICE);\r\n        PowerManager.WakeLock powerOn=pm.newWakeLock(PowerManager.FULL_WAKE_LOCK | PowerManager.ACQUIRE_CAUSES_WAKEUP,\"poweron\");\r\n        powerOn.acquire();\r\n        powerOn.release();\r\n        Log.e(\"Datacollector\",\"Turn screen on\");\r\n    }*/\r\n\r\n    /*\r\n        NEXT TASK\r\n     */\r\n    private void setSettingsFromDefault(){\r\n        File settingsFile = new File(Environment.getExternalStorageDirectory(), DEFAULT_SETTINGS_FILE_NAME);\r\n        try {\r\n            if(!settingsFile.exists()) {\r\n                System.out.println(\"NO LOCAL BACKUP. RESORTING TO DEFAULT...\");\r\n                saveDefaultSettingsFile(settingsFile);\r\n            } else{\r\n                BufferedReader fileReader = new BufferedReader(new FileReader(settingsFile));\r\n                String[] settingsData = fileReader.readLine().split(\",\");\r\n                if(settingsData[0].equals(USER_ID)){\r\n                    System.out.println(\"USING SETTINGS FROM LAST RUN ON LOCAL BACKUP...\");\r\n                    BACKOFF_TIME = Integer.parseInt(settingsData[1]);\r\n                    MAX_STIM = Integer.parseInt(settingsData[2]);\r\n                    ONSET_CONFIDENCE = Float.parseFloat(settingsData[3]);\r\n                    E_STOP = Float.parseFloat(settingsData[4]);\r\n                    BUFFER_SIZE = Integer.parseInt(settingsData[5]);\r\n                } else{\r\n                    System.out.println(\"LOCAL BACKUP DOES NOT MATCH USER ID. RESORTING TO DEFAULT...\");\r\n                    saveDefaultSettingsFile(settingsFile);\r\n                }\r\n            }\r\n        } catch(IOException e){\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Maximizes the System volume\r\n     * In conjunction with onKeyDown override (see below) ensures that System volume is always set to max\r\n     */\r\n    private void maximizeSystemVolume(){\r\n        AudioManager audioManager = (AudioManager) getApplicationContext().getSystemService(this.AUDIO_SERVICE);\r\n        int maxVolume = audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);\r\n        audioManager.setStreamVolume(AudioManager.STREAM_MUSIC, maxVolume, 0);\r\n\r\n    }\r\n\r\n    private void saveDefaultSettingsFile(){\r\n        File settingsFile = new File(Environment.getExternalStorageDirectory(), DEFAULT_SETTINGS_FILE_NAME);\r\n        saveDefaultSettingsFile(settingsFile);\r\n    }\r\n\r\n    private void saveDefaultSettingsFile(File settingsFile){\r\n        try {\r\n            if(!settingsFile.exists()) {\r\n                settingsFile.createNewFile();\r\n            }\r\n            BufferedWriter fileWriter = new BufferedWriter(new FileWriter(settingsFile, false));\r\n            fileWriter.write(USER_ID + \",\" + BACKOFF_TIME + \",\" + MAX_STIM + \",\" + ONSET_CONFIDENCE + \",\" + E_STOP + \",\" + BUFFER_SIZE);\r\n            fileWriter.close();\r\n        } catch(IOException e){\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private void getUserID(){\r\n        File userIDFile = new File(Environment.getExternalStorageDirectory(), USER_ID_FILE_NAME);\r\n        try {\r\n            if(!userIDFile.exists()) {\r\n                userIDFile.createNewFile();\r\n                setUserID(DEFAULT_USER_ID);\r\n                USER_ID = DEFAULT_USER_ID;\r\n            }\r\n            else{\r\n                BufferedReader fileReader = new BufferedReader(new FileReader(userIDFile));\r\n                USER_ID = fileReader.readLine();\r\n            }\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        Button userIDButton = (Button)findViewById(R.id.USERID);\r\n        userIDButton.setText(new String(\"SET USER ID: \" + USER_ID));\r\n    }\r\n\r\n    private void setUserID(String newID){\r\n        setUserID(newID, new File(Environment.getExternalStorageDirectory(), USER_ID_FILE_NAME));\r\n    }\r\n\r\n    private void setUserID(String newID, File userIDFile) {\r\n        try {\r\n            BufferedWriter fileWriter = new BufferedWriter(new FileWriter(userIDFile, false));\r\n            fileWriter.write(newID);\r\n            fileWriter.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        getUserID();\r\n    }\r\n\r\n    private void alertSetNewID(){\r\n        AlertDialog.Builder builder = new AlertDialog.Builder(this);\r\n        builder.setTitle(\"Set New ID:\");\r\n        final EditText input = new EditText(this);\r\n        input.setInputType(InputType.TYPE_CLASS_TEXT);\r\n        input.setText(USER_ID);\r\n        builder.setView(input);\r\n\r\n        builder.setPositiveButton(\"OK\", new DialogInterface.OnClickListener() {\r\n            @Override\r\n            public void onClick(DialogInterface dialog, int which) {\r\n                String userID = input.getText().toString();\r\n                userID = userID.toUpperCase();\r\n                userID = userID.replaceAll(\" \", \"_\");\r\n                if(userID.length() == 0){\r\n                    userID = DEFAULT_USER_ID;\r\n                }\r\n                USER_ID = userID;\r\n                setUserID(USER_ID);\r\n                getUserSettings();\r\n            }\r\n        });\r\n        builder.setNegativeButton(\"Cancel\", new DialogInterface.OnClickListener() {\r\n            @Override\r\n            public void onClick(DialogInterface dialog, int which) {\r\n                dialog.cancel();\r\n            }\r\n        });\r\n        builder.show();\r\n    }\r\n\r\n    // todo: override all user settings\r\n    private void getUserSettings(){\r\n        new Thread(new Runnable() {\r\n            public void run() {\r\n                //LINK TO SETTINGS PER USER:\r\n\r\n                // todo: make it so the user can place a file here instead of reading this URL every time\r\n                String settingsDataLink = \"https://raw.githubusercontent.com/nathanww/stroke-tmr-settings/main/SETTINGS.txt\";\r\n                List<String[]> settingsData = new ArrayList<>();\r\n                try {\r\n                    URL url = new URL(settingsDataLink);\r\n                    url.openStream();\r\n                    BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\r\n                    String currentLine = null;\r\n                    while((currentLine = reader.readLine()) != null){\r\n                        settingsData.add(currentLine.replaceAll(\" \", \"\").split(\",\"));\r\n                    }\r\n                    reader.close();\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                boolean hit = false;\r\n                for(String[] line: settingsData){\r\n                    if(line[0].equals(USER_ID)){\r\n                        hit = true;\r\n                        BACKOFF_TIME = Integer.parseInt(line[1]);\r\n                        MAX_STIM = Integer.parseInt(line[2]);\r\n                        ONSET_CONFIDENCE = Float.parseFloat(line[3]);\r\n                        E_STOP = Float.parseFloat(line[4]);\r\n                        BUFFER_SIZE = Integer.parseInt(line[5]);\r\n                        if(line.length >= 7){\r\n                            if(line[6].contains(\"FILES\")){\r\n                                MediaHandler overrideHandler = new GitMediaHandler(getApplicationContext(), line[6]);\r\n                                overrideHandler.readFiles();\r\n                                final float volume = server.md.getVolume();\r\n                                overrideHandler.setMediaVolume(volume, volume);\r\n                                if(server.md.isMediaPlaying()){\r\n                                    overrideHandler.startMedia();\r\n                                }\r\n                                server.md = overrideHandler;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if(!hit){\r\n                    System.out.println(\"COULD NOT CONNECT TO SERVER OR FIND USERNAME. LOOKING FOR LOCAL BACKUP...\");\r\n                    setSettingsFromDefault();\r\n                } else{ //if(hit)\r\n                    saveDefaultSettingsFile();\r\n                }\r\n                System.out.println(\"CURRENT SETTINGS:\\n------------------------------\");\r\n                System.out.println(\"BACKOFF_TIME: \" + BACKOFF_TIME);\r\n                System.out.println(\"MAX_STIM: \" + MAX_STIM);\r\n                System.out.println(\"ONSET_CONFIDENCE: \" + ONSET_CONFIDENCE);\r\n                System.out.println(\"E_STOP: \" + E_STOP);\r\n                System.out.println(\"BUFFER_SIZE: \" + BUFFER_SIZE);\r\n\r\n            }\r\n        }).start();\r\n    }\r\n\r\n    void wakeupHandler() { //turn the screen on (if turned off) during recording period to improve acquistion reliability. Also checks the connection status and tries to reset thje connection if ti appears broken\r\n        final Handler wakeuptimer = new Handler();\r\n        Runnable runnableCode = new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                PowerManager pm = (PowerManager) getSystemService(POWER_SERVICE);\r\n                PowerManager.WakeLock powerOn = pm.newWakeLock(PowerManager.FULL_WAKE_LOCK | PowerManager.ACQUIRE_CAUSES_WAKEUP, \"poweron\");\r\n                powerOn.acquire();\r\n                powerOn.release();\r\n                Log.e(\"Datacollector\", \"Turn screen on\");\r\n                //check connection status and reset if needed\r\n                if (System.currentTimeMillis() - lastpacket > 10000) { //last Fitbit data was received more than 10 seconds ago\r\n                    fixConnection();\r\n                }\r\n\r\n                wakeuptimer.postDelayed(this, 60000);\r\n\r\n            }\r\n        };\r\n// Start the initial runnable task by posting through the handler\r\n        wakeuptimer.post(runnableCode);\r\n\r\n    }\r\n\r\n    private void openDreem(){\r\n        Intent launchIntent = getPackageManager().getLaunchIntentForPackage(\"co.rythm.dreem.med\");\r\n        if (launchIntent != null) {\r\n            startActivity(launchIntent);//null pointer check in case package name was not found\r\n            System.out.println(\"DREEM APPLICATION OPENED\");\r\n        } else{\r\n            System.out.println(\"DREEM APPLICATION NOT FOUND\");\r\n        }\r\n    }\r\n\r\n\r\n    private void fixConnection() {\r\n        //Toggle Bluetooth on and off and start the Fitbit app inb order to fix connection issues\r\n        conFixArm=true; //enable app to self-restart\r\n        BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();\r\n        /*\r\n        if (mBluetoothAdapter.isEnabled()) {\r\n            mBluetoothAdapter.disable();\r\n            mBluetoothAdapter.enable();\r\n        }\r\n        else {\r\n            mBluetoothAdapter.enable();\r\n        }*/\r\n\r\n        // now start the Fitbit app, this should trigger a re-sync if it hasn't synced in a while and re open the TMR app in a cpuple of seconds\r\n\r\n        if (getDeviceName().indexOf(\"G930\") > -1) { //only do this on our S7 devices, because on other devices the app self-restart doesn't work\r\n            Intent launchIntent = getPackageManager().getLaunchIntentForPackage(\"com.fitbit.FitbitMobile\");\r\n            if (launchIntent != null) {\r\n                startActivity(launchIntent);//null pointer check in case package name was not found\r\n            }\r\n        }\r\n    }\r\n\r\n    private void resetStim() { //resets all stmulation parameters\r\n        getUserSettings();\r\n        turnedOnTime=System.currentTimeMillis();\r\n        whiteNoiseVolume = volumePreferences.getFloat(\"volume\", 1.0f);\r\n        cueNoise = whiteNoiseVolume+CUE_NOISE_OFFSET;\r\n        backoff_time=System.currentTimeMillis()+BACKOFF_TIME;\r\n        stim_seconds=0;\r\n\r\n\r\n    }\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n\r\n\r\n        super.onCreate(savedInstanceState);\r\n        final Context cont = this;\r\n        Log.i(\"fitbit\",\"oncreate was called\");\r\n        getUserSettings();\r\n         AppUpdater ud=new AppUpdater(this);\r\n                ud.setUpdateFrom(UpdateFrom.JSON)\r\n                .setUpdateJSON(\"https://raw.githubusercontent.com/nathanww/home-tmr/stroke2/app/release/update.json\")\r\n                .start();\r\n\r\n        //we need runtime permission to create files in the shared storage, so request it\r\n        int check = ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE);\r\n        while (check != PackageManager.PERMISSION_GRANTED) {\r\n            requestPermissions(new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},1024);\r\n            check = ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE);\r\n        }\r\n        probBuffer.add(0.01f);\r\n        probBuffer.add(0.01f);\r\n        //prevent the CPU from sleeping\r\n        PowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE);\r\n        final PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,\r\n                \"DreamCatcher::DataCollection\");\r\n        //Remove title bar\r\n        this.requestWindowFeature(Window.FEATURE_NO_TITLE);\r\n        //Remove notification bar\r\n        this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);\r\n\r\n        setContentView(R.layout.activity_main_simple); //use just the simple layout for now\r\n        final Button startButton = (Button) findViewById(R.id.startButton);\r\n\r\n\r\n        //start the power handler\r\n        wakeupHandler();\r\n        //start the web server\r\n        startButton.setEnabled(false);\r\n        wakeLock.acquire();// get the wakelock\r\n        DataHandler DataHandlerTask = new DataHandler();\r\n        DataHandlerTask.execute();\r\n\r\n        //start the Fitbit server\r\n        server = new fitbitServer();\r\n        try {\r\n            server.start();\r\n        } catch(IOException ioe) {\r\n            Log.w(\"Httpd\", \"The server could not start.\");\r\n        }\r\n        Log.w(\"Httpd\", \"Web server initialized.\");\r\n\r\n        fileServer = new savedDataServer();\r\n        try {\r\n            fileServer.start();\r\n        } catch(IOException ioe) {\r\n            Log.w(\"Httpd\", \"The FILE server could not start.\");\r\n        }\r\n        Log.w(\"Httpd\", \"Web FILE server initialized.\");\r\n\r\n        Button stopButton = (Button) findViewById(R.id.stopButton);\r\n        stopButton.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                wakeLock.release();\r\n                server.stop();\r\n                server=null;\r\n                System.exit(0);\r\n            }\r\n        });\r\n        //set up the audio player\r\n        //final MediaPlayer mp = MediaPlayer.create(this, R.raw.sleepmusic);\r\n\r\n        final MediaHandler mdtest = new TestMediaHandler(this);\r\n        mdtest.readFiles();\r\n        //mp.setLooping(true);\r\n        //mp.setVolume(1.0f,1.0f);\r\n        final Button testButton = (Button) findViewById(R.id.testButton);\r\n        testButton.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                if (!isPlaying) {\r\n                    mdtest.startMedia();\r\n                    //mp.start();\r\n                    testButton.setText(\"Stop sound\");\r\n                }\r\n                else {\r\n                    mdtest.pauseMedia();\r\n                    //mp.pause();\r\n                    testButton.setText(\"Test sound\");\r\n\r\n                }\r\n                isPlaying = !isPlaying;\r\n            }\r\n        });\r\n        /*\r\n        final Button downloadButton = (Button) findViewById(R.id.downloadButton);\r\n        downloadButton.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                fileServer.startTransmit();\r\n                downloadButton.setEnabled(false);\r\n            }\r\n        });\r\n        downloadButton.setEnabled(false);*/\r\n        getUserID();\r\n\r\n        final Button userIDButton = (Button)findViewById(R.id.USERID);\r\n        userIDButton.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                alertSetNewID();\r\n            }\r\n        });\r\n\r\n        volumePreferences = getSharedPreferences(\"volume_preferences\", MODE_PRIVATE);\r\n        whiteNoiseVolume = volumePreferences.getFloat(\"volume\", 1.0f);\r\n        cueNoise = whiteNoiseVolume+CUE_NOISE_OFFSET;\r\n        volumeBar = (SeekBar) findViewById(R.id.volumeBar);\r\n        int displayVolume = (int) (whiteNoiseVolume * volumeBar.getMax());\r\n\r\n        volumeBar.setProgress(displayVolume);\r\n        volumeText = (TextView) findViewById(R.id.volumeText);\r\n        volumeText.setText(String.valueOf(displayVolume));\r\n        volumeBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {\r\n            @Override\r\n            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {\r\n                volumeText.setText(String.valueOf(progress));\r\n                whiteNoiseVolume = new Float((progress / ((float) volumeBar.getMax()))*maxNoise);\r\n                cueNoise = whiteNoiseVolume+CUE_NOISE_OFFSET;\r\n                mdtest.setMediaVolume(cueNoise, cueNoise);\r\n                whiteNoise.setVolume(whiteNoiseVolume, whiteNoiseVolume);\r\n                if (progress < 1) {\r\n                    volumeBar.setProgress(1);\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void onStartTrackingTouch(SeekBar seekBar) {\r\n                maximizeSystemVolume();\r\n            }\r\n\r\n            @Override\r\n            public void onStopTrackingTouch(SeekBar seekBar) {\r\n                SharedPreferences.Editor editor = volumePreferences.edit();\r\n                editor.putFloat(\"volume\", whiteNoiseVolume);\r\n                editor.commit();\r\n            }\r\n        });\r\n\r\n        whiteNoise = MediaPlayer.create(this, R.raw.whitenoise);\r\n        whiteNoise.setLooping(true);\r\n        whiteNoise.setVolume(whiteNoiseVolume, whiteNoiseVolume);\r\n        tmrStateButton = (ToggleButton) findViewById(R.id.tmrState);\r\n        tmrStateButton.setTextColor(Color.parseColor(\"#FFFFFF\"));\r\n        //tmrStateButton.setBackgroundColor(Color.parseColor(\"#FF0000\"));\r\n        tmrStateButton.setBackgroundColor(Color.parseColor(\"#008000\"));\r\n\r\n        tmrStateButton.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\r\n            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\r\n                if (isChecked) {\r\n                    if(System.currentTimeMillis() - lastpacket < 10000 || DEBUG_MODE) {\r\n                        resetStim();\r\n                        whiteNoise.start();\r\n                        tmrStateButton.setBackgroundColor(Color.parseColor(\"#FF0000\"));\r\n                        turnedOnTime=System.currentTimeMillis();\r\n                    } else{\r\n\r\n                        //\r\n                        AlertDialog alertDialog = new AlertDialog.Builder(MainActivity.this).create();\r\n                        alertDialog.setTitle(\"Connection Error\");\r\n                        alertDialog.setMessage(\"Fitbit is not connected. Make sure it is charged and on your wrist and try again in a minute.\");\r\n                        alertDialog.setButton(AlertDialog.BUTTON_NEUTRAL, \"OK\",\r\n                                new DialogInterface.OnClickListener() {\r\n                                    public void onClick(DialogInterface dialog, int which) {\r\n                                        dialog.dismiss();\r\n                                        Intent launchIntent = getPackageManager().getLaunchIntentForPackage(\"com.fitbit.FitbitMobile\");\r\n                                        if (launchIntent != null) {\r\n                                            startActivity(launchIntent);//null pointer check in case package name was not found\r\n                                        }\r\n                                    }\r\n                                });\r\n                        alertDialog.show();\r\n                        tmrStateButton.setChecked(false);\r\n                    }\r\n                } else {\r\n                    whiteNoise.pause();\r\n                    tmrStateButton.setBackgroundColor(Color.parseColor(\"#008000\"));\r\n                    stim_seconds = 0;\r\n                    cueNoise = whiteNoiseVolume+CUE_NOISE_OFFSET;\r\n                    mdtest.setMediaVolume(cueNoise, cueNoise);\r\n                }\r\n            }\r\n        });\r\n\r\n        MediaHandler test = new GitMediaHandler(getApplicationContext(), \"FILES:s1.wav:s2.wav\");\r\n        test.readFiles();\r\n        maximizeSystemVolume();\r\n        getUserSettings();\r\n\r\n        final Button dreemOpenButton = (Button) findViewById(R.id.openDreem);\r\n        dreemOpenButton.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                openDreem();\r\n            }\r\n        });\r\n        if (getDeviceName().indexOf(\"G930\") > -1) { //this button is used on the stroke system (Galaxy A10) but not on the home TMR system (S7)\r\n            dreemOpenButton.setVisibility(View.GONE);\r\n        }\r\n\r\n        }\r\n\r\n    @Override\r\n    protected void onResume() {\r\n        maximizeSystemVolume();\r\n        super.onResume();\r\n    }\r\n\r\n\r\n    @Override\r\n    public boolean onKeyDown(int keyCode, KeyEvent event) {\r\n        if(keyCode==KeyEvent.KEYCODE_VOLUME_DOWN){\r\n            return true;\r\n        }\r\n        else if(keyCode==KeyEvent.KEYCODE_VOLUME_UP){\r\n            return true;\r\n        }\r\n        else{\r\n            return super.onKeyDown(keyCode, event);\r\n        }\r\n    }\r\n\r\n    //stop the server when app is closed\r\n    @Override\r\n    public void onDestroy()\r\n    {\r\n        super.onDestroy();\r\n        if (server != null)\r\n            server.stop();\r\n\r\n        if (fileServer != null)\r\n            fileServer.stop();\r\n    }\r\n\r\n\r\n\r\n    //fitbitServer handles getting data from the fitbit which sends it on port 8085\r\n    private class fitbitServer extends NanoHTTPD {\r\n        int telemetryCount=0;\r\n        /*\r\n        private boolean initiateDownloadPrevious = false;\r\n        private boolean downloadPrevious = false;\r\n        private boolean downloadAcknowledged = false;\r\n        private int downloadCount = 0;\r\n        */\r\n        PrintWriter fitbitWriter;\r\n        //MediaPlayer mp;\r\n        MediaHandler md;\r\n        public fitbitServer() {\r\n            super(8085);\r\n            Log.i(\"fitbit\",\"server start\");\r\n            //set up the audio player\r\n            //mp = MediaPlayer.create(getApplicationContext(), R.raw.sleepmusic);\r\n            //mp.setLooping(true);\r\n            //mp.setVolume(1.0f,1.0f);\r\n            md = new MediaHandler(getApplicationContext());\r\n            md.readFiles();\r\n\r\n            final Handler fitbitWakeup = new Handler();\r\n\r\n            final int delay = 15000; //milliseconds\r\n            fitbitWakeup.postDelayed(new Runnable(){\r\n                public void run(){\r\n                    if (System.currentTimeMillis() > lastpacket+10000) { //no data from the fitbit\r\n\r\n                        if (md.isMediaPlaying()){\r\n                            md.pauseMedia();\r\n                        }\r\n\r\n\r\n\r\n\r\n                    }\r\n                    //DEBUG CODE--MAKES THE SOUNDS START IMMEDIATELY\r\n                    if (DEBUG_MODE) {\r\n                        ONSET_DELAY = 0;\r\n                        handleStaging(0.99f);\r\n                        Log.i(\"debug\",\" loop ran\");\r\n\r\n                            fitbitWakeup.postDelayed(this, 3000);\r\n\r\n                    }\r\n                    else {\r\n                        fitbitWakeup.postDelayed(this, delay);\r\n                    }\r\n                }\r\n            }, delay);\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n        private float average(ArrayList<Float> data) {\r\n            float sum = 0;\r\n            for (int i=0; i< data.size(); i++) {\r\n                sum += data.get(i);\r\n            }\r\n            return sum / data.size();\r\n        }\r\n        String handleStaging(float prob) {\r\n            Log.e(\"stage\",prob+\"\");\r\n            String tmrStatus=\"0,\";\r\n            probBuffer.add(prob);\r\n            if (probBuffer.size() > BUFFER_SIZE) {\r\n                probBuffer.remove(0);\r\n            }\r\n            float avgProb=average(probBuffer);\r\n            Log.e(\"avg\",\"\"+avgProb);\r\n            if (prob >= E_STOP && avgProb >= ONSET_CONFIDENCE && System.currentTimeMillis() >= turnedOnTime+ONSET_DELAY && System.currentTimeMillis() < turnedOnTime+OFFSET_DELAY) {\r\n                above_thresh=1;\r\n            }\r\n            else {\r\n                above_thresh=0;\r\n                above_thresh=0;\r\n                /*\r\n                if (mp.isPlaying()) {\r\n                    mp.pause();\r\n                    targetVolume=targetVolume-0.1f;\r\n                    if (targetVolume < 0.1) {\r\n                        targetVolume=0;\r\n                    }\r\n                    mp.setVolume(targetVolume,targetVolume);\r\n                    backoff_time=System.currentTimeMillis()+BACKOFF_TIME; //stim woke them up, so pause it\r\n                }\r\n                 */\r\n                if (md.isMediaPlaying()){\r\n                    md.pauseMedia();\r\n                    /*\r\n                    targetVolume=targetVolume-0.1f;\r\n                    if(targetVolume < 0.1){\r\n                        targetVolume=0;\r\n                    }\r\n                    */\r\n                    cueNoise -= 0.3f;\r\n                    if(cueNoise < 0.0f){\r\n                        cueNoise = 0.0f;\r\n                    }\r\n\r\n                    //decrease the maximum cue volume too if it looks like a wakeup was triggered\r\n                    if (prob < E_STOP) {\r\n                        whiteNoiseVolume = whiteNoiseVolume - MAX_ADAPTION_STEP;\r\n                        if (whiteNoiseVolume < 0.01f) {\r\n                            whiteNoiseVolume=0.01f;\r\n                        }\r\n                    }\r\n                    md.setMediaVolume(cueNoise, cueNoise);\r\n                    backoff_time=System.currentTimeMillis()+BACKOFF_TIME; //stim woke them up, so pause it\r\n                }\r\n            }\r\n\r\n            if (System.currentTimeMillis() < backoff_time || stim_seconds >= MAX_STIM ||  !tmrStateButton.isChecked()) {\r\n                if (md.isMediaPlaying()){\r\n                    md.pauseMedia();\r\n                }\r\n               /*\r\n               if (mp.isPlaying()) {\r\n                    mp.pause();\r\n                }\r\n                */\r\n            }\r\n            else {\r\n                if (above_thresh > 0 && (tmrStateButton.isChecked()||DEBUG_MODE)) { //we are stably in stage, start playing the media\r\n                    Log.i(\"media\",\"run\");\r\n                    tmrStatus = \"1,\";\r\n                    stim_seconds++;\r\n                    /*\r\n                    targetVolume=targetVolume+volumeInc;\r\n                    if (targetVolume > 1) {\r\n                        targetVolume=1.0f;\r\n                    }\r\n                     */\r\n                    cueNoise += volumeInc;\r\n                    if(cueNoise > whiteNoiseVolume+CUE_NOISE_MAX){\r\n                        cueNoise = whiteNoiseVolume+CUE_NOISE_MAX;\r\n                    }\r\n                    md.setMediaVolume(cueNoise, cueNoise);\r\n                    if (!md.isMediaPlaying()){\r\n                        md.startMedia();\r\n                    }\r\n                    /*\r\n                    mp.setVolume(targetVolume,targetVolume);\r\n                    if (!mp.isPlaying()) {\r\n                        mp.start();\r\n                    }\r\n                    */\r\n                } else {\r\n                    tmrStatus = \"0,\";\r\n                }\r\n            }\r\n            //tmrStatus=tmrStatus+prob+\",\"+String.valueOf(md.getMediaPosition())+\",\"+String.valueOf(targetVolume)+\",\"+md.getCurrentMedia();\r\n            tmrStatus=tmrStatus+prob+\",\"+String.valueOf(md.getMediaPosition())+\",\"+ String.valueOf(cueNoise);\r\n            return tmrStatus;\r\n        }\r\n\r\n        public Response serve(String uri, Method method,\r\n                              Map<String, String> header,\r\n                              Map<String, String> parameters,\r\n                              Map<String, String> files) {\r\n            Log.e(\"fitbitserver\", \"request\");\r\n            if (uri.indexOf(\"rawdata\") > -1) { //recieved a data packet from the Fitbit, set the Fitbit status to good.\r\n                lastpacket = System.currentTimeMillis();\r\n                runOnUiThread(new Runnable() {\r\n\r\n                    @Override\r\n                    public void run() {\r\n                        TextView fStatus = (TextView) findViewById(R.id.fConnectionStatus);\r\n                        fStatus.setText(\"✔️ Fitbit connected\");\r\n                    }\r\n                });\r\n                ToggleButton tmrStateButton = (ToggleButton) findViewById(R.id.tmrState);\r\n                if (tmrStateButton.isChecked()) { //only do the rest if the TMR has actually been turned on\r\n\r\n\r\n                /*\r\n                if(downloadPrevious) {\r\n                    String message = parameters.toString();\r\n                    System.out.println(message);\r\n                    if (message.contains(\"DOWNLOAD_ACKNOWLEDGEMENT\")) {\r\n                        System.out.println(\"1\");\r\n                        downloadAcknowledged = true;\r\n                        return newFixedLengthResponse(Response.Status.OK, \"confirm0\", \"\");\r\n                    } else if (message.contains(\"EXIT_DOWNLOAD\")) {\r\n                        downloadPrevious = false;\r\n                        return newFixedLengthResponse(Response.Status.OK, \"exit\", \"\");\r\n                    } else if (downloadAcknowledged) {\r\n                        System.out.println(\"2\");\r\n                        //write parameters.toString() to datalog file\r\n                        downloadCount++;\r\n                        return newFixedLengthResponse(Response.Status.OK, \"confirm\" + String.valueOf(downloadCount), \"\");\r\n                    } else {\r\n                        System.out.println(\"3\");\r\n                        return newFixedLengthResponse(Response.Status.OK, \"waiting_for_acknowledgement\", \"\");\r\n                    }\r\n                }\r\n                */\r\n                    String staging = \"\";\r\n                    String is3current = \"unset\";\r\n                    //check to see if stages are available\r\n                    if (parameters.toString().indexOf(\"is3\") > -1) { //yes they are\r\n                        String split = parameters.toString().split(\"( is3=1 )\")[1];\r\n                        split = split.split(\",\")[0].replace(\")\\\":\", \"\");\r\n                        float prob;\r\n                        try {\r\n                            prob = Float.parseFloat(split);\r\n                        } catch (NumberFormatException e) {\r\n                            prob = 0;\r\n                        }\r\n\r\n                        is3current = String.valueOf(prob);\r\n                        staging = handleStaging(prob);\r\n                        Log.e(\"stage3\", split);\r\n                    }\r\n                /*\r\n                String staging=\"\";\r\n                if (true) { //yes they are\r\n                    System.out.println(\"FORCING STAGING\");\r\n                    staging=handleStaging(Float.parseFloat(\"1.0\"));\r\n                    Log.e(\"stage3\",\"1\");\r\n                }\r\n                */\r\n\r\n                    String[] fitbitParams = parameters.toString().replace(\":\", \",\").split(\",\"); //split up individual data vals\r\n\r\n                    fitbitStatus = parameters.toString().split(\"data=\\\\{\")[1];\r\n\r\n                    String hrCurrent = (fitbitParams[1]); //HEART RATE\r\n                    String batteryCurrent = (fitbitParams[19].split(\"STAGE\")[0].replace(\"}\", \"\")); //BATTERY\r\n                    //Log.e(\"fitbit\",fitbitStatus);\r\n                    fitbitBuffer = fitbitBuffer + fitbitStatus + \",\" + staging + \"\\n\";\r\n                    fitbitCount++;\r\n                    if (fitbitCount > FITBIT_WRITE_INTERVAL) {\r\n                        try {\r\n                            FileWriter fileWriter = new FileWriter(getApplicationContext().getExternalFilesDir(null) + \"/fitbitdata.txt\", true);\r\n                            PrintWriter printWriter = new PrintWriter(fileWriter);\r\n                            printWriter.print(fitbitBuffer);  //New line\r\n                            printWriter.flush();\r\n                            printWriter.close();\r\n                            fitbitCount = 0;\r\n                            fitbitBuffer = \"\";\r\n                        } catch (IOException e) {\r\n                            Log.e(\"Fitbitserver\", \"Error writing to file\");\r\n                        }\r\n                    }\r\n\r\n                    String is3average;\r\n                    if (probBuffer.size() > 0) {\r\n                        is3average = String.valueOf(average(probBuffer));\r\n                    } else {\r\n                        is3average = \"unset\";\r\n                    }\r\n\r\n                    String mediaPlayingCurrently = String.valueOf(md.isMediaPlaying());\r\n                    String cueCountCurrently = String.valueOf(md.getCueCount());\r\n\r\n                    String volumeCurrently = String.valueOf(md.getVolume());\r\n\r\n                    String isPhonePluggedInCurrently = String.valueOf(isPluggedIn());\r\n                    PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);\r\n                    String isScreenOnCurrently = String.valueOf(pm.isInteractive());\r\n\r\n                    //REMOTE TELEMETRY FUNCTIONALITY\r\n                    //Heart rate - hrCurrent\r\n                    //Current probability of stage 3 - is3current\r\n                    //Averaged probability of stage 3 - is3average\r\n                    //Is TMR running or not - mediaPlayingCurrently\r\n                    //Current volume - volumeCurrently\r\n                    //FB battery level - batteryCurrent\r\n                    //Phone plugged in - isPhonePluggedInCurrently\r\n                    //Phone screen on - isScreenOnCurrently\r\n\r\n                    //send a telemetry thing only once evwery minute to avoid using ridiculuous amounts of data\r\n                    telemetryCount++;\r\n                    if (telemetryCount >= 60 || getDeviceName().indexOf(\"G930\") == -1) { //transmit data every second if not on the G7 because the other phones have bigger data plans\r\n                        telemetryCount = 0;\r\n                        JSONObject remoteTeleData = new JSONObject();\r\n                        try {\r\n                            remoteTeleData.put(\"hr\", hrCurrent);\r\n                            remoteTeleData.put(\"is3\", is3current);\r\n                            remoteTeleData.put(\"is3avg\", is3average);\r\n                            remoteTeleData.put(\"TMRon\", mediaPlayingCurrently);\r\n                            remoteTeleData.put(\"vlm\", volumeCurrently);\r\n                            remoteTeleData.put(\"bat\", batteryCurrent);\r\n                            remoteTeleData.put(\"plugin\", isPhonePluggedInCurrently);\r\n                            remoteTeleData.put(\"scrnOn\", isScreenOnCurrently);\r\n                            remoteTeleData.put(\"fullStatus\", fitbitStatus);\r\n                        } catch (JSONException e) {\r\n                            e.printStackTrace();\r\n                        }\r\n                        try {\r\n                            String urlString = \"https://biostream-1024.appspot.com/sendps?user=\" + USER_ID + \"&data=\" + URLEncoder.encode(remoteTeleData.toString(), StandardCharsets.UTF_8.toString());\r\n                            HttpPost httpPost = new HttpPost(urlString);\r\n                            System.out.println(\"tele\" + urlString);\r\n                            Log.i(\"telemetry\", \"send\");\r\n                            URL url = new URL(urlString);\r\n                            url.openStream();\r\n                        } catch (Exception e) {\r\n                            Log.e(\"telemetry\", \"error\");\r\n                            e.printStackTrace();\r\n                        }\r\n                    }\r\n\r\n\r\n                }\r\n                // Log.i(\"server\", parameters.toString());\r\n            /*\r\n            //update the Fitbit status\r\n            if(initiateDownloadPrevious){\r\n                initiateDownloadPrevious = false;\r\n                downloadPrevious = true;\r\n                downloadCount = 0;\r\n                return newFixedLengthResponse(Response.Status.OK, \"download\", \"\");\r\n            }\r\n            else{\r\n\r\n            }\r\n             */\r\n            }\r\n\r\n                return newFixedLengthResponse(Response.Status.OK, \"normal\", \"\");\r\n            }\r\n\r\n    }\r\n\r\n    //Server for downloading datalog.txt data, used on port 9000\r\n    private class savedDataServer extends NanoHTTPD{\r\n        boolean beginTransfer = false;\r\n        boolean start = true;\r\n        List<String> inputs = new ArrayList<String>();\r\n        List<String> outputs = new ArrayList<String>();\r\n        int currentLine = 0;\r\n        List<String> lines = new ArrayList<>();\r\n\r\n        public savedDataServer() {\r\n            super(9000);\r\n        }\r\n\r\n        public Response serve(String uri, Method method,\r\n                              Map<String, String> header,\r\n                              Map<String, String> parameters,\r\n                              Map<String, String> files) {\r\n            String message = parameters.toString();\r\n            message = message.substring(6, message.indexOf(\", NanoHttpd.QUERY_STRING=\"));\r\n            System.out.println(\"RECEIVED: \" + message);\r\n            inputs.add(message);\r\n            /*\r\n            if(outputs.size() > 0){\r\n                return handleResponse(inputs.get(inputs.size()-1), outputs.get(outputs.size()-1));\r\n            }\r\n            else{\r\n                return handleResponse(inputs.get(inputs.size()-1), \"\");\r\n            }\r\n            */\r\n            return handleResponse();\r\n        }\r\n\r\n        private Response handleResponse(){\r\n            /*\r\n            DOWNLOAD BUTTON TEXT COLOR:\r\n                - RED: INITIATING TRANSFER\r\n                - ORANGE: SUCCESSFUL INITIATION, STARTING LINE REQUESTS\r\n                - YELLOW: SUCCESSFUL LINE REQUEST, COMPLETING LINE REQUESTS\r\n                - YELLOWGREEN: SUCCESSFUL LINE REQUESTS TO END OF FILE, REQUESTING CLEAR FILE\r\n                - GREEN: FILE CLEARED, PROCESS COMPLETED\r\n             */\r\n            if(!beginTransfer){\r\n                runOnUiThread(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        ((Button) findViewById(R.id.downloadButton)).setEnabled(true);\r\n                    }\r\n                });\r\n                return buildResponse(\"PASS\");\r\n            }\r\n            else{\r\n                System.out.println(getLastInput() + \" -> \" + getLastOutput());\r\n                if(getLastInput().startsWith(\"PASSED\")){\r\n                    start = false;\r\n                    ((Button) findViewById(R.id.downloadButton)).setTextColor(Color.parseColor(\"#FF0000\")); //red\r\n                    return buildResponse(\"INITIATE\");\r\n                }\r\n                else if(getLastOutput().startsWith(\"INITIATE\")){\r\n                    if(getLastInput().startsWith(\"SUCCESS\")){\r\n                        ((Button) findViewById(R.id.downloadButton)).setTextColor(Color.parseColor(\"#FFA500\")); //orange\r\n                        return buildResponse(\"LINE_\" + currentLine);\r\n                    }\r\n                    else{\r\n                        return buildResponse(\"INITIATE\");\r\n                    }\r\n                }\r\n                else if(getLastOutput().startsWith(\"LINE\")){\r\n                    if(!getLastInput().startsWith(\"LINE\")){\r\n                        return buildResponse(getLastOutput());\r\n                    }\r\n                    LineInput lineInput = new LineInput(getLastInput());\r\n                    if(currentLine == lineInput.getLineNumber()){\r\n                        if(lineInput.getCommandType().equals(\"DATA\")){\r\n                            ((Button) findViewById(R.id.downloadButton)).setTextColor(Color.parseColor(\"#FFFF00\")); //yellow\r\n                            lines.add(lineInput.getData());\r\n                            currentLine++;\r\n                            return buildResponse(\"LINE_\" + currentLine);\r\n                        }\r\n                        else if(lineInput.getCommandType().equals(\"INIT\")){\r\n                            return buildResponse(\"INITIATE\");\r\n                        }\r\n                        else if(lineInput.getCommandType().equals(\"EXIT\")){\r\n                            if(saveToFile()){\r\n                                ((Button) findViewById(R.id.downloadButton)).setTextColor(Color.parseColor(\"#9ACD32\")); //yellowgreen\r\n                                return buildResponse(\"CLEAR\");\r\n                            }\r\n                            else{\r\n                                return buildResponse(\"LINE_\" + currentLine);\r\n                            }\r\n                        }\r\n                    } else{\r\n                        return buildResponse(\"LINE_\" + currentLine);\r\n                    }\r\n\r\n                }\r\n                else if(getLastOutput().startsWith(\"CLEAR\")) {\r\n                    if(getLastInput().startsWith(\"SUCCESS\")){\r\n                        ((Button) findViewById(R.id.downloadButton)).setTextColor(Color.parseColor(\"#008000\")); //green\r\n                        lines = new ArrayList<String>();\r\n                        outputs = new ArrayList<String>();\r\n                        inputs = new ArrayList<String>();\r\n                        currentLine = new Integer(0);\r\n                        beginTransfer = false;\r\n                        start = true;\r\n                        return buildResponse(\"PASS\");\r\n                    }\r\n                    else{\r\n                        return buildResponse(\"CLEAR\");\r\n                    }\r\n                }\r\n                return buildResponse(\"ERROR\");\r\n            }\r\n        }\r\n\r\n        private boolean saveToFile(){\r\n            File storageDirectory = Environment.getExternalStorageDirectory();\r\n            String storageFileName = \"SAVED_DATA_\" + System.currentTimeMillis() + \".txt\";\r\n            File storageFile = new File(storageDirectory, storageFileName);\r\n            try {\r\n                if(!storageFile.exists()) {\r\n                    storageFile.createNewFile();\r\n                }\r\n                BufferedWriter writer = new BufferedWriter(new FileWriter(storageFile, true));\r\n                for(String line: lines){\r\n                    writer.write(line + \"\\n\");\r\n                }\r\n                writer.close();\r\n                return true;\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n                return false;\r\n            }\r\n        }\r\n\r\n        private String getLastOutput(){\r\n            return outputs.get(outputs.size()-1);\r\n        }\r\n\r\n        private String getLastInput(){\r\n            return inputs.get(inputs.size()-1);\r\n        }\r\n\r\n        private Response buildResponse(String message){\r\n            outputs.add(message);\r\n            System.out.println(message);\r\n            return newFixedLengthResponse(Response.Status.OK, message,\"\");\r\n        }\r\n        /*\r\n        private Response sendAcknowledgement(){\r\n            currentLine = -1;\r\n            return newFixedLengthResponse(Response.Status.OK, \"INITIATE_TRANSMIT\", \"\");\r\n        }\r\n\r\n        private Response storeData(String line){\r\n            //Put the line in data storage\r\n            currentLine++;\r\n            return newFixedLengthResponse(Response.Status.OK, \"CONFIRM:\" + currentLine.toString(), \"\");\r\n        }\r\n        private Response exit(){\r\n            beginTransfer = false;\r\n            currentLine = null;\r\n            return newFixedLengthResponse(Response.Status.OK, \"COMPLETED_EXIT\", \"\");\r\n        }\r\n        */\r\n        public void startTransmit() {\r\n            beginTransfer = true;\r\n        }\r\n\r\n        private class LineInput{\r\n            private int LineNumber;\r\n            private String CommandType;\r\n            private String Data;\r\n            public LineInput(String line){\r\n                System.out.println(\"LINEINPUT\");\r\n                System.out.println(line);\r\n                String[] broken = line.split(\"_\");\r\n                for (String i:\r\n                     broken) {\r\n                    System.out.println(i);\r\n                }\r\n                LineNumber = Integer.parseInt(broken[1]);\r\n                CommandType = broken[2];\r\n                if(CommandType.equals(\"DATA\")){\r\n                    Data = broken[3];\r\n                }\r\n            }\r\n\r\n            public String getData(){\r\n                return Data;\r\n            }\r\n\r\n            public String getCommandType(){\r\n                return CommandType;\r\n            }\r\n\r\n            public int getLineNumber() {\r\n                return LineNumber;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n    //NOTE: TIS FUNCTION IS NOT CURRENTLY USED BECAUSE WE ARE NO LONGER USING THE ZMAX SENSOR\r\n    //DataHandler receives zMax data and writes it to a file\r\n    //Note--data is stored in UNSCALED form\r\n    //THis function is based on the matlab code at http://hypnodynecorp.com/downloads/HDConnect.m\r\n    private class DataHandler extends AsyncTask<Void, String, Void> {\r\n        private Socket client;\r\n        private PrintWriter printwriter;\r\n        private String messsage;\r\n        private Context mContext;\r\n        String dataBuffer = \"\";\r\n        int BUFFER_SIZE=1500;\r\n        double MIN_QUAL=100;\r\n        double[] eegLeftBuffer=new double[BUFFER_SIZE]; //buffered EEG data for evaluating signal quality\r\n        double[] eegRightBuffer=new double[BUFFER_SIZE];\r\n        double[] stds=new double[BUFFER_SIZE];\r\n\r\n        //take standard deviation of EEG channels\r\n        //if a channel is disocnnected it will be flat, with little stdev\r\n        //todo: low pass filter before, to remove variation indcued by amplifier artifacts when a channel is disconnected\r\n        public double computeQuality(int EEG_L,int EEG_R) {\r\n            eegLeftBuffer[BUFFER_SIZE-1]=EEG_L; //update buffers w new data\r\n            eegRightBuffer[BUFFER_SIZE-1]=EEG_R;\r\n            //shift buffers\r\n            for (int i=0; i < BUFFER_SIZE-1; i++) {\r\n                eegLeftBuffer[i]=eegLeftBuffer[i+1];\r\n                eegRightBuffer[i]=eegRightBuffer[i+1];\r\n            }\r\n            // double corr= new PearsonsCorrelation().correlation(eegLeftBuffer, eegRightBuffer);\r\n            double stdleft=new StandardDeviation().evaluate(eegLeftBuffer);\r\n            double stdright=new StandardDeviation().evaluate(eegRightBuffer);\r\n            if (stdright < stdleft) {\r\n                stds[BUFFER_SIZE - 1] = stdright;\r\n            }\r\n            else {\r\n                stds[BUFFER_SIZE - 1] = stdleft;\r\n            }\r\n            //shift moving average and take mean across the time window\r\n            double total=0;\r\n            double samples=0;\r\n            for (int i=0; i < BUFFER_SIZE-1; i++) {\r\n                stds[i]=stds[i+1];\r\n                total=total+stds[i];\r\n                samples++;\r\n            }\r\n\r\n            return total/samples;\r\n        }\r\n\r\n        @Override\r\n        protected Void doInBackground(Void... params) {\r\n            /*\r\n            Log.i(\"Record\", \"Recording started\");\r\n            try {\r\n\r\n                client = new Socket(\"127.0.0.1\", 24000); // connect to the server\r\n                printwriter = new PrintWriter(client.getOutputStream(), true);\r\n                printwriter.write(\"HELLO\\n\"); // write the message to output stream\r\n\r\n                printwriter.flush();\r\n\r\n                InputStream is = client.getInputStream();\r\n                while (true) {\r\n                    int c = is.read();\r\n                    if (c != -1) {\r\n                        byte db = (byte) c;\r\n                        //Log.e(\"data\",\"data\");\r\n                        if (db == '\\n') {\r\n                            if (dataBuffer.length() > 1) { //we have just completed a sample, now process it\r\n                                String[] splitup = dataBuffer.split(\"\\\\.\");\r\n                                if (splitup.length > 1) { //the stuff after the period is the actual data\r\n                                    String[] theData = splitup[1].split(\"-\"); //split into individual hex digits\r\n                                    int packetType = (int) Long.parseLong(theData[0], 16);\r\n                                    if (packetType >= 1 && packetType <= 11) { //first digit specifies the type of packet this is; we only process it if it's a dat apacket\r\n                                        int EEG_R=getWordAt(theData,1);\r\n                                        int EEG_L=getWordAt(theData,3);\r\n                                        int ACC_X=getWordAt(theData,5);\r\n                                        int ACC_Y=getWordAt(theData,7);\r\n                                        int ACC_Z=getWordAt(theData,9);\r\n                                        int PPG = getWordAt(theData,27);\r\n                                        int BODYTEMP=getWordAt(theData,36);\r\n                                        int AMBIENTLIGHT=getWordAt(theData,21);\r\n                                        int BATTERYPOWER=getWordAt(theData,23);\r\n                                        int AMBIENTNOISE=getWordAt(theData,19);\r\n                                        double EEG_QUALITY=computeQuality(EEG_L,EEG_R); //EEG signal quality from standard deviation\r\n                                        String zmaxStatus=System.currentTimeMillis()+\",\"+EEG_R+\",\"+EEG_L+\",\"+ACC_X+\",\"+ACC_Y+\",\"+ACC_Z+\",\"+PPG+\",\"+BODYTEMP+\",\"+AMBIENTLIGHT+\",\"+BATTERYPOWER+\",\"+AMBIENTNOISE+\",\"+EEG_QUALITY+\"\\n\";\r\n                                        zMaxBuffer=zMaxBuffer+zmaxStatus;\r\n                                        zMaxCount++;\r\n                                        if (zMaxCount > ZMAX_WRITE_INTERVAL) {\r\n                                            try {\r\n                                                FileWriter zWriter = new FileWriter(getApplicationContext().getExternalFilesDir(null) + \"/zmaxdata.txt\", true);\r\n                                                PrintWriter printWriter = new PrintWriter(zWriter);\r\n                                                printWriter.print(zMaxBuffer);\r\n                                                printWriter.flush();\r\n                                                printWriter.close();\r\n                                                zMaxCount=0;\r\n                                                zMaxBuffer=\"\";\r\n                                            } catch (IOException e) {\r\n                                                Log.e(\"Zmaxserver\", \"Error writing to file\");\r\n                                            }\r\n                                        }\r\n\r\n\r\n                                        //valid packet received, so update the connection status\r\n                                        TextView zCon = (TextView) findViewById(R.id.zConnectionStatus);\r\n                                        publishProgress(\"zmaxconnected\");\r\n\r\n                                        if ( EEG_QUALITY < MIN_QUAL) { //EEG is bad if the correlation is Nan (no variation in at least one channel, implies that the channel is pegged at max or min), or if the channels are too correlated\r\n                                            publishProgress(\"zmaxbadsignal\");\r\n                                        }\r\n                                        else {\r\n                                            publishProgress(\"zmaxgoodsignal\");\r\n                                        }\r\n                                    } else {\r\n                                        Log.i(\"Error\", \"Wrong packet type\");\r\n                                    }\r\n                                }\r\n                            }\r\n                            dataBuffer = \"\";\r\n                        }\r\n                        dataBuffer = dataBuffer + (char) db;\r\n\r\n\r\n                    }\r\n\r\n\r\n                }\r\n            } catch (UnknownHostException e) {\r\n                e.printStackTrace();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n            return null;\r\n            */\r\n            return null;\r\n        }\r\n\r\n        @Override\r\n        protected void onProgressUpdate(String... values) { //handles updating the UI\r\n            if (values[0].equals(\"zmaxconnected\")) {\r\n                TextView zStatus = (TextView) findViewById(R.id.zConnectionStatus);\r\n                //zStatus.setText(\"✔️ zMax connected\");\r\n            }\r\n            if (values[0].equals(\"zmaxbadsignal\")) {\r\n                TextView zStatus = (TextView) findViewById(R.id.zSignalStatus);\r\n                //zStatus.setText(\"⚠️️ Poor forehead signal\");\r\n            }\r\n            if (values[0].equals(\"zmaxgoodsignal\")) {\r\n                TextView zStatus = (TextView) findViewById(R.id.zSignalStatus);\r\n                //zStatus.setText(\"✔️️️ Good forehead signal\");\r\n            }\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/neurelectrics/fitbitdatalogger/MainActivity.java	(revision 00902f20789eb9b5cfbf7c3a57e71eff89a4fc4e)
+++ app/src/main/java/neurelectrics/fitbitdatalogger/MainActivity.java	(date 1616468796238)
@@ -81,7 +81,7 @@
     float MAX_ADAPTION_STEP=0.015f; //If cues seem to trigger a wakeup, drop the max volume we can reach by this much
     long ONSET_DELAY=60*60*1000; //minimumj delay before cues start
     long OFFSET_DELAY=3*60*60*1000;
-    boolean DEBUG_MODE=false; //if true, app simulates stage 3 sleep
+    boolean DEBUG_MODE=true; //if true, app simulates stage 3 sleep
     long turnedOnTime=0;
     int above_thresh=0;
     double backoff_time=0;
